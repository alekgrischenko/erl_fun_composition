Учебный проект, где рассматриваются различные способы композиции функций в Erlang.

# Intro

Эрланг -- язык с динамической типизаций.

С одной стороны это просто, не нужно заморачиваться со сложными вариантами композиции, как в Haskell пиши что хочешь, компилятор всем доволен.

С другой стороны сложно. Если типы и правильность композиции не проверяет компилятор, то эти приходится делать программисту в уме.

С третьей стороны, у нас есть dialyzer. Он весьма крут во многих случаях. И хорошо бы получать от него пользу, где это возможно.


# Задача

У нас есть книжный магазин для котов. Он принимает заказы и доставляет книги.

У магазина есть API для создания заказа.

На входе API принимает json-данные, содержащие информацию о коте-заказчике, его адресс и книги, которые кот хочет заказать.

Например:
```
{
  "cat": "Tihon",
  "address": "Coolcat str 7/42 Minsk Belarus",
  "books": [
    {"title": "Domain Modeling Made Functional", "author": "Scott Wlaschin"},
    {"title": "Удовольствие от Х", "author": "Стивен Строгац"},
    {"title": "Distributed systems for fun and profit", "author": "Mikito Takada"}
  ]
}
```

На выходе валидный бизнес-объект типа Order, который передается дальше в систему для обработки; или ошибка, которая возвращается клиенту API, если с данными что-то не так.

Для проверки данных и создания валидного объекта Order нужно выполнить следующие шаги:
- проверить кота по имени
- проверить его адрес
- проверить каждую книгу в списке
- создать Order

Для этого у нас есть следущие функции:
```
-spec validate_incoming_data(JsonData :: map()) -> {ok, map()} | {error, invalid_incoming_data}.

-spec validate_cat(CatName :: binary()) -> {ok, cat()} | {error, cat_not_found}.

-spec validate_address(Address :: binary()) -> {ok, address()} | {error, invalid_address}.

-spec get_book(Title :: binary(), Author :: binary()) -> {ok, book()} | {error, {book_not_found, binary()}}.

-spec create_order(Cat :: cat(), Address :: address(), Books :: [book()]) -> order().
```

Нужно выполнить композицию этих функций.



# Вариант 1. Решение в лоб

Плюсы: очевидное
Минусы: трудно читать, трудно менять. А что, если шагов не 4, а 15?


# Вариант 2. Цепочка функций, без вложеных case, с накоплением данных в стейте.

Плюсы: понятное, читаемое, расширяемое
Минусы: копипаста, шаблонный код.


# Вариант 3. Решение на исключениях

Работает. Читаемо. Расширяемо. Имеет полное право на существование.
Но трудно отследить все точки выхода, найти все варианты, что может пойти не так.
ну и это не ФП путь


# Вариант 4. Pipeline. bind & sequence

Для соединения функций в цепочку удобна инфиксная форма вызова функции.

Префиксная форма: fun arg1 arg2
Инфиксная форма: arg1 fun arg2

В префикстой форме цепочка выглядит так:
bind(bind(bind(fun1, fun2), fun3), fun4)

В инфиксной форме так:
fun1 >>= fun2 >>= fun3 >>= fun4

Увы, в эрланге инфиксной формы для функций нет. Будем что-то придумывать.

Еще одна проблема это то, что нам нужно не просто соединить функции в цепочку,
но еще сохранить промежуточные результаты, чтобы использовать их позже.

Вариант -- складывать все промежуточные результаты в некий State,
и пробрасывать этот State через все функции.

Плюсы: понятное, читаемое, расширяемое

Минусы:

Работает только с функциями, специально предназначеными для pipeline -- State на входе, {ok, State} на выходе.
другие функции приходится оборачивать, и тогда нет выйгрыша в сравнении с вариантом 2.

Типы проверяются диалайзером только поверхностно. {ok, term()} | {error, term()}.
а что там в term(), не проверяется.


# Вариант 5. do-нотация

Другой способ сохранять и использовать промежуточные результаты -- do-нотация.
В эрланге этого, конечно, нет. Но можно попытаться придумать некий DSL с похожей семантикой.

Реализация не production ready, но для эксперимента ок.
Например, непонятно, как лучше обработать ситуацию, когда ключа-аргумента нет в стейте.
Сейчас там будет краш, со стектрейсом, показывающим кишки реализации.
То есть, пользователь этого DSL должен влезать в детали реализации.
Стало быть, я сделал недостаточно хорошую абстракцию.
Впрочем, это проблема многих DSL :)

Плюсы: типа, как в Хаскеле, по-крутому

Минусы:
нифига не как в Хаскеле, никакой проверки типов нет
ваши коллеги не скажут вам спасибо за такой код


# Выводы

В реальности на практике я применяю варианты 2 и 4.
4й вариант подразумевает, что все функции соединяются одинаково.
В 2-м варианте много гибкости.

Вариант 3? Никто особо не удивится, если вы напишите такой код. Пишите, если хотите. Я так не делаю.

Вариант 5? Не делайте так. Хотите писать как в Хаскеле, пишите на Хаскеле :)

Во 2м варианте диалайзер прекрасно найдет все ошибки.
В 4-м кое-что может найти, но глубоко не полезет.
В 5-м варианте вообще ничего не проверяется.


# Либы

https://github.com/fogfish/datum
кажется, тут больше про структуры данных, чем про композицию функций

https://github.com/habibutsu/erlz
https://github.com/yzh44yzh/erlz
а вот тут как раз про композицию. Но эта библиотека без ориентации на dialyzer, так что пользы от нее меньше, чем хотелось бы.
