В данном учебном проекте я рассматриваю способы композиции функций в Erlang.

На примере конкретной прикладной задачи я предлагаю 5 вариантов композиции. Начинаю с простых и понятных, и двигаюсь к более сложным способам, характерным для функционального программирования. Анализирую плюсы и минусы каждого варианта, рекомендую, что лучше использовать в реальном проекте.

Все варианты актуальны и для Elixir.


# Задача

У нас есть книжный магазин для котов. Он принимает заказы и доставляет книги.

У магазина есть API для создания заказа.

На входе API принимает json-данные, содержащие информацию о коте-заказчике, его адресс, и книги, которые кот хочет заказать.

Например:
```
{
  "cat": "Tihon",
  "address": "Coolcat str 7/42 Minsk Belarus",
  "books": [
    {"title": "Domain Modeling Made Functional", "author": "Scott Wlaschin"},
    {"title": "Удовольствие от Х", "author": "Стивен Строгац"},
    {"title": "Distributed systems for fun and profit", "author": "Mikito Takada"}
  ]
}
```

На выходе из API мы имеем валидный бизнес-объект Order, который передается дальше в систему для обработки, или ошибку валидации.

Для проверки данных и создания валидного объекта Order нужно выполнить следующие шаги:
- проверить кота по имени
- проверить его адрес
- проверить каждую книгу в списке
- создать Order

Для этого у нас есть следущие функции:
```
-spec validate_incoming_data(JsonData :: map()) ->
    {ok, map()} | {error, invalid_incoming_data}.

-spec validate_cat(CatName :: binary()) ->
    {ok, cat()} | {error, cat_not_found}.

-spec validate_address(Address :: binary()) ->
    {ok, address()} | {error, invalid_address}.

-spec get_book(Title :: binary(), Author :: binary()) ->
    {ok, book()} | {error, {book_not_found, binary()}}.

-spec create_order(Cat :: cat(), Address :: address(), Books :: [book()]) ->
    order().
```

То есть, у нас есть 3 функции, которые могут вернуть успешный результат, либо ошибку. Четвертая функция, которую нужно применить несколько раз к элементам списка. И, наконец, пятая функция, которая всегда возвращает успешный результат.

Нужно выполнить композицию этих функций.

[books_shop.erl](./src/books_shop.erl)


# Вариант 1. Решение в лоб -- вложеные case.

[main_1.erl](./src/main_1.erl)

Здесь получилось 4 уровня вложености. Пока что это не так страшно. Но что, если понадобится добавить еще один шаг валидации? Два шага? Десять? Или переставить некоторые шаги местами?

Такой код -- явный пример, как не надо делать. Тем не менее, тут есть пару плюсов. Во-первых, он работает правильно. Во-вторых, он хорошо проверяется dialyzer.

Я не поленился создать пользовательские типы данных и написать spec ко всем функциям. Так что теперь dialyzer может проверить правильность композиции функций.


# Вариант 2. Каждый case в отдельную функцию.

[main_2.erl](./src/main_2.erl)

У нас получилось 6 небольших функций, вызывающих друг друга по очереди. И некий общий State, который проходит через все эти вызовы. State нужен, чтобы накапливать промежуточные результаты и передавать их дальше.

Каждая функция маленькая и понятная. Тут легко добавить два, пять, десять, сколько угодно новых шагов валидации. Легко менять их местами.

dialyzer по-прежнему контролирует правильность композиции. Но за правильностью использования State разработчику придется следить самому. Тут появляются возможности для ошибок.

Кроме того функции похожи -- они повторяют одинаковый шаблон. И это наводит на мысль, что можно что-то обобщить, сократить количество кода.


# Вариант 3. Решение с использованием исключений.

[main_3.erl](./src/main_3.erl)

Шаблонность кода вызывана тем, что результат каждого вызова нужно проверить на ошибку. Попробуем переделать модуль books_shop, чтобы его функции сообщали об ошибках через исключения, а не через возвращаемое значение.

Получилось очень просто, лаконично. Код пишем только для happy path. *try..catch* решает все остальные проблемы. Красота!

В таком простом примере это решение может показаться самым лучшим. Но в больших проектах исключения создают некоторые проблемы.

Во-первых, понадобится много разных типов исключений и стратегия их использования -- какой тип для чего применять. Если разработчиков на проекте больше одного, то таких стратегий может оказаться больше одной. И тогда неизвестные исключения вдруг прилетают из неожиданных мест.

Во-вторых, вызывая функцию, разработчик не может знать всех возможных вариантов ее завершения. Разве что прочитает ее код и проследит все внутренние вызовы на всю глубину. В решениях 1 и 2 все возможные варианты завершения функции описаны в ее спецификации. По хорошему, спецификация могла бы содержать инфу, какие исключения могут возникнуть (как в Java). Но в Erlang этого нет.

В использовании исключений ничего плохого нет (даже если некоторые ФП программисты будут говорить вам обратное). Но в мире Erlang так сложилось, что ими пользуются редко.


# Вариант 4. Pipeline, bind и sequence.


Исключения дали нам возможность сосредоточиться на happy path и не мучаться с шаблонной обработкой ошибок. Но в функциональном программировании есть другие инструменты с таким же эффектом.

Сейчас, извините, будет немного Haskell. Дело в том, что Haskell может показать нужные нам идеи в эталонном виде. А в Erlang мы может реализовать только что-то похожее, с некоторым приближением. Так что, прежде, чем смотреть на искаженную копию, сперва посмотрим на оригинал.

Сначала нам нужны те же функции валидации, реализованые на Haskell: [BookShop.hs](./hs_src/BookShop.hs)

Тип данных *Either ErrResult SuccessResult* -- это аналог эрланговского *{ok, SuccessResult} | {error, ErrResult}*.

Теперь мы будем соединять эти функции в цепочку. Это легко, когда результат одной функции совпадает с аргументом другой. Но что делать, если не совпадает? Собственно, вокруг этого и строится все ФП :)

Если на выходе из функции нужное нам значение завернуто в Either, а на входе другой функции это значение нужно в чистом виде, то соединить эти две функции можно оператором *bind*.

```
fun1 >== fun2
```

Это оператор делает именно то, что делали наши маленькие функции во 2-м варианта -- с помощью case проверяет результат первой функции, и либо вызывает следующую, либо возвращает ошибку.

Имея несколько таких функций, их можно соединить в цепочку оператором bind:
```
fun1 >== fun2 >== fun3 >== fun4
```

Получится то же самое, что во 2-м варианте, но без явных case.

Решение на Haskell выглядит так: [Main4.hs](./hs_src/Main4.hs) (Да, это монады, но не важно :).

С Erlang нас ожидает трудность -- нет оператора bind, и нет никакого способа его имитировать. Но способ убрать явный case есть. Мы можем цепочку функций представить как список функций, и выполнить свертку над этим списком.
```
pipeline:bind(Data, [
    fun1,
    fun2,
    fun3
    fun4
]).
```

Сама по себе эта свертка реализуется тривиально:
```
bind(Arg, Funs) ->
    lists:foldl(
        fun
            (Fun, {ok, PrevRes}) -> Fun(PrevRes);
            (_, {error, Error}) -> {error, Error}
        end,
        {ok, Arg},
        Funs).
```

Но позволяет получить лаконичный код:
[main_4.erl](./src/main_4.erl)

Отдельно посмотрим на валидацию списка книг. Прогнав этот список через *books_shop:validate_book/2*, мы получим:
```
[{ok, Book1}, {ok, Book2}, {ok, Book3}]
```
или для Haskell:
```
[Right Book1, Right Book2, Right Book3]
```

Но нам нужно другое. Нам нужно:
```
{ok, [Book1, Book2, Book3]}
```
или
```
Right [Book1, Book2, Book3]
```

Первое во второе легко превратить с помощью *sequence*. Это стандартная функция в Haskell, но ее легко реализовать в Erlang.

Есть еще одна проблема в Erlang, которой нет в Haskell. Если предыдущие варианты хорошо контролировались dialyzer, то 4-й уже нет. Dialyzer ничего не может сказать о том, подходят ли функции в списке друг к другу. Поэтому лучше всего, чтобы все функции были одинаковые по сигнатуре:
```
-spec fun(my_state()) -> {ok, my_state()} | {error, some_error()}.
```
Что, собственно, и сделано в 4-м варианте (кроме последней функции).

4-й вариант лаконичнее 2-го варианта. Но выйгрыш не такой большой, потому что задача для него не самая подходящая. Функции *books_shop* не ложатся в pipeline непосредственно, их нужно оборачивать. Другое дело, если бы функции специально писались под использование в pipeline. Тогда выйгрыш был бы больше.

На самом деле, я эту задачу составлял специально для 5-го варианта :)


# Вариант 5. do-нотация

Что же нам мешает применить pipeline? Мешает то, что нам нужно не просто перекидывать значения из одной функции в другую, а сохранить промежуточные результаты, чтобы использовать их позже. И в этом случае подходит do-нотация.

TODO stopped here

Очень похоже на вариант 3, с исключениями. Только здесь нет исключений :)

Плюсы: понятное, читаемое, расширяемое

Минусы:

Работает только с функциями, специально предназначеными для pipeline -- State на входе, {ok, State} на выходе.
другие функции приходится оборачивать, и тогда нет выйгрыша в сравнении с вариантом 2.

Типы проверяются диалайзером только поверхностно. {ok, term()} | {error, term()}.
а что там в term(), не проверяется.



Другой способ сохранять и использовать промежуточные результаты -- do-нотация.
В эрланге этого, конечно, нет. Но можно попытаться придумать некий DSL с похожей семантикой.

Тут тоже, сперва решение на Haskell, затем на Erlang.

Реализация не production ready, но для эксперимента ок.
Например, непонятно, как лучше обработать ситуацию, когда ключа-аргумента нет в стейте.
Сейчас там будет краш, со стектрейсом, показывающим кишки реализации.
То есть, пользователь этого DSL должен влезать в детали реализации.
Стало быть, я сделал недостаточно хорошую абстракцию.
Впрочем, это проблема многих DSL :)

Плюсы: типа, как в Хаскеле, по-крутому

Минусы:
нифига не как в Хаскеле, никакой проверки типов нет
ваши коллеги не скажут вам спасибо за такой код


# Какие вообще есть способы композиции?

точка, $, & или |> (pipe)
<$>, <*>
>>= bind, >> fmap
=<<
<=< >=> рыба


В эликсире
только |>

В эрланге ничего


# Выводы

Выводы
- можно написать без исключений? можно
- можно использовать исключения? можно
- можно ли сделать "как в хаскеле"? поиграться можно, а в прод не надо. Как это отлаживать? Как будут выглядеть стек-трейсы при крашах?

В реальности на практике я применяю варианты 2 и 4.
4й вариант подразумевает, что все функции соединяются одинаково.
В 2-м варианте много гибкости.

Вариант 3? Никто особо не удивится, если вы напишите такой код. Пишите, если хотите. Я так не делаю.

Вариант 5? Не делайте так. Хотите писать как в Хаскеле, пишите на Хаскеле :)

Во 2м варианте диалайзер прекрасно найдет все ошибки.
В 4-м кое-что может найти, но глубоко не полезет.
В 5-м варианте вообще ничего не проверяется.

порекомендовать книгу
Domain Modeling Made Functional. by Scott Wlaschin
