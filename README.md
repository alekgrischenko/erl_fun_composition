В данном учебном проекте я рассматриваю способы композиции функций в Erlang.

На примере конкретной прикладной задачи я предлагаю 5 вариантов композиции. Начинаю с простых и понятных, и двигаюсь к более сложным способам, характерным для функционального программирования. Анализирую плюсы и минусы каждого варианта, рекомендую, что лучше использовать в реальном проекте.

Все варианты актуальны и для Elixir.


# Задача

У нас есть книжный магазин для котов. Он принимает заказы и доставляет книги.

У магазина есть API для создания заказа.

На входе API принимает json-данные, содержащие информацию о коте-заказчике, его адресс, и книги, которые кот хочет заказать.

Например:
```
{
  "cat": "Tihon",
  "address": "Coolcat str 7/42 Minsk Belarus",
  "books": [
    {"title": "Domain Modeling Made Functional", "author": "Scott Wlaschin"},
    {"title": "Удовольствие от Х", "author": "Стивен Строгац"},
    {"title": "Distributed systems for fun and profit", "author": "Mikito Takada"}
  ]
}
```

На выходе из API мы имеем валидный бизнес-объект Order, который передается дальше в систему для обработки, или ошибку валидации.

Для проверки данных и создания валидного объекта Order нужно выполнить следующие шаги:
- проверить кота по имени
- проверить его адрес
- проверить каждую книгу в списке
- создать Order

Для этого у нас есть следущие функции:
```
-spec validate_incoming_data(JsonData :: map()) ->
    {ok, map()} | {error, invalid_incoming_data}.

-spec validate_cat(CatName :: binary()) ->
    {ok, cat()} | {error, cat_not_found}.

-spec validate_address(Address :: binary()) ->
    {ok, address()} | {error, invalid_address}.

-spec get_book(Title :: binary(), Author :: binary()) ->
    {ok, book()} | {error, {book_not_found, binary()}}.

-spec create_order(Cat :: cat(), Address :: address(), Books :: [book()]) ->
    order().
```

То есть, у нас есть 3 функции, которые могут вернуть успешный результат, либо ошибку. Четвертая функция, которую нужно применить несколько раз к элементам списка. И, наконец, пятая функция, которая всегда возвращает успешный результат.

Нужно выполнить композицию этих функций.

[books_shop.erl](./src/books_shop.erl)


# Вариант 1. Решение в лоб -- вложеные case.

[main_1.erl](./src/main_1.erl)

Здесь получилось 4 уровня вложености. Пока что это не так страшно. Но что, если понадобится добавить еще один шаг валидации? Два шага? Десять? Или переставить некоторые шаги местами?

Такой код -- явный пример, как не надо делать. Тем не менее, тут есть пару плюсов. Во-первых, он работает правильно. Во-вторых, он хорошо проверяется dialyzer.

Я не поленился создать пользовательские типы данных и написать spec ко всем функциям. Так что теперь dialyzer может проверить правильность композиции функций.


# Вариант 2. Каждый case в отдельную функцию.

[main_2.erl](./src/main_2.erl)

У нас получилось 6 небольших функций, вызывающих друг друга по очереди. И некий общий State, который проходит через все эти вызовы. State нужен, чтобы накапливать промежуточные результаты и передавать их дальше.

Каждая функция маленькая и понятная. Тут легко добавить два, пять, десять, сколько угодно новых шагов валидации. Легко менять их местами.

dialyzer по-прежнему контролирует правильность композиции. Но за правильностью использования State разработчику придется следить самому. Тут появляются возможности для ошибок.

Кроме того функции похожи -- они повторяют одинаковый шаблон. И это наводит на мысль, что можно что-то обобщить, сократить количество кода.


# Вариант 3. Решение с использованием исключений.

[main_3.erl](./src/main_3.erl)

Шаблонность кода вызывана тем, что результат каждого вызова нужно проверить на ошибку. Попробуем переделать модуль books_shop, чтобы его функции сообщали об ошибках через исключения, а не через возвращаемое значение.

Получилось очень просто, лаконично. Код пишем только для happy path. *try..catch* решает все остальные проблемы. Красота!

В таком простом примере это решение может показаться самым лучшим. Но в больших проектах исключения создают некоторые проблемы.

Во-первых, понадобится много разных типов исключений и стратегия их использования -- какой тип для чего применять. Если разработчиков на проекте больше одного, то таких стратегий может оказаться больше одной. И тогда неизвестные исключения вдруг прилетают из неожиданных мест.

Во-вторых, вызывая функцию, разработчик не может знать всех возможных вариантов ее завершения. Разве что прочитает ее код и проследит все внутренние вызовы на всю глубину. В решениях 1 и 2 все возможные варианты завершения функции описаны в ее спецификации. По хорошему, спецификация могла бы содержать инфу, какие исключения могут возникнуть (как в Java). Но в Erlang этого нет.

В использовании исключений ничего плохого нет (даже если некоторые ФП программисты будут говорить вам обратное). Но в мире Erlang так сложилось, что ими пользуются редко.


# Вариант 4. Pipeline, bind и sequence.


Исключения дали нам возможность сосредоточиться на happy path и не мучаться с шаблонной обработкой ошибок. Но в функциональном программировании есть другие инструменты с таким же эффектом.

Сейчас, извините, будет немного Haskell. Дело в том, что Haskell может показать нужные нам идеи в эталонном виде. А в Erlang мы может реализовать только что-то похожее, с некоторым приближением. Так что прежде, чем смотреть на искаженную копию, сперва посмотрим на оригинал.

Сначала нам нужны те же функции валидации, реализованые на Haskell: [BookShop.hs](./hs_src/BookShop.hs)

Тип данных *Either ErrResult SuccessResult* -- это аналог эрланговского *{ok, SuccessResult} | {error, ErrResult}*.

Теперь мы будем соединять эти функции в цепочку. Это легко, когда результат одной функции совпадает с аргументом другой. Но что делать, если не совпадает? Собственно, вокруг этого и строится все ФП :)

Если на выходе из функции нужное нам значение завернуто в Either, а на входе другой функции это значение нужно в чистом виде, то соединить эти две функции можно оператором *bind*.

```
fun1 >== fun2
```

Это оператор делает именно то, что делали наши маленькие функции во 2-м варианта -- с помощью case проверяет результат первой функции, и либо вызывает следующую, либо возвращает ошибку.

Имея несколько таких функций, их можно соединить в цепочку оператором bind:
```
fun1 >== fun2 >== fun3 >== fun4
```

Получится то же самое, что во 2-м варианте, но без явных case.

Решение на Haskell выглядит так: [Main4.hs](./hs_src/Main4.hs) (Да, это монады, но не важно :).

С Erlang нас ожидает трудность -- нет оператора bind, и нет никакого способа его имитировать. Но способ убрать явный case есть. Мы можем цепочку функций представить как список функций, и выполнить свертку над этим списком.
```
pipeline:bind(Data, [
    fun1,
    fun2,
    fun3
    fun4
]).
```

Сама по себе эта свертка реализуется тривиально:
```
bind(Arg, Funs) ->
    lists:foldl(
        fun
            (Fun, {ok, PrevRes}) -> Fun(PrevRes);
            (_, {error, Error}) -> {error, Error}
        end,
        {ok, Arg},
        Funs).
```

Но позволяет получить лаконичный код:
[main_4.erl](./src/main_4.erl)

Отдельно посмотрим на валидацию списка книг. Прогнав этот список через *books_shop:validate_book/2*, мы получим:
```
[{ok, Book1}, {ok, Book2}, {ok, Book3}]
```
или для Haskell:
```
[Right Book1, Right Book2, Right Book3]
```

Но нам нужно другое. Нам нужно:
```
{ok, [Book1, Book2, Book3]}
```
или
```
Right [Book1, Book2, Book3]
```

Первое во второе легко превратить с помощью *sequence*. Это стандартная функция в Haskell, и ее легко реализовать в Erlang.

Есть еще одна проблема в Erlang, которой нет в Haskell. Если предыдущие варианты хорошо контролировались dialyzer, то 4-й вариант уже нет. Dialyzer ничего не может сказать о том, подходят ли функции в списке друг к другу. Поэтому лучше всего, чтобы все функции были одинаковые по сигнатуре:
```
-spec fun(my_state()) -> {ok, my_state()} | {error, some_error()}.
```
Что, собственно, и сделано в 4-м варианте (кроме последней функции).

4-й вариант лаконичнее 2-го варианта. Но выйгрыш не такой большой, потому что задача для него не самая подходящая. Функции *books_shop* не ложатся в pipeline непосредственно, их нужно оборачивать. Другое дело, если бы *books_shop* специально писался под использование в pipeline. Тогда выйгрыш был бы больше.

На самом деле, я эту задачу составлял для 5-го варианта :)


# Вариант 5. do-нотация.

Что же нам мешает применить pipeline? Мешает то, что нам нужно не просто перекидывать значения из одной функции в другую, а сохранять промежуточные результаты, чтобы использовать их позже. И в этом случае подходит do-нотация.

Давайте посмотрим, как это выглядит в Haskell: [Main5.hs](./hs_src/Main5.hs)

А выглядит это очень похоже на вариант 3 с исключениями. Только здесь нет исключений :)

Мы видим два способа получить результат выполнения функции. Стрелка влево *<-* извлекает результат из Either, знак присваивания *=* извлекает обычное значение. Получеными значениями можно пользоваться ниже. Если какая-то функция вернет ошибку, то выполнение блока *do* прерывается, и ошибка возвращается как результат.

Для Haskell это самый простой и лаконичный вариант. А что с Erlang? У нас опять нет ни блока *do*, ни магических стрелок. Зато есть сама идея сохранять промежуточные результаты в каком-то контексте и потом пользоваться ими.

Не имея встроеных средств языка, можно попробовать придумать некий DSL. Смотрим [main_5.erl](./src/main_5.erl).

Получилось тоже лаконично, но вряд ли понятно без дополнительный пояснений. Мы опять видим список. Здесь элементы списка не просто функции, а кортежи из трех элементов, где посередине находится функция, слева атом, а справа либо атом, либо что-то другое. Можно догадаться, что справа -- аргументы функции, а слева ее результат.

Где-то в недрах реализации прячется контекст -- обыкновенная *map*. Атомы слева и справа -- это ключи, по которым читаются и записываются значения в контекст. Аргументом функции может быть либо конкретное значение, либо атом, и тогда значение берется из контекста. Результат функции по заданому ключу сохраняется в контексте. Последний сохраненный результат -- это результат всего блока *do*. Если какая-то функция вернет ошибку, то выполнение всего блока прекращается, и возвращается ошибка.

DSL на самом деле простой, и его реализация тоже простая [wannabe_haskell.erl](./src/wannabe_haskell.erl).

Ну так что, у нас получилось не хуже Haskell? Не совсем. Во-первых, как и с 4-м вариантом, dialyzer тут не может проверить типы. Во-вторых, представьте, как вы будете объяснять свой код коллегам, которые почему-то не знают про do-нотацию :) В-третьих, можно себе представить, каково отлаживать ошибки в таком коде, и как будут выглядеть стектрейсы при крэшах.

Для эксперимента это неплохо. При желании можно как-то развивать такой DSL, но брать в реальные проекты вряд ли стоит.


# Выводы

Вполне годны к использованию варианты:
- 2-й, каждый case в отдельной функции;
- 3-й, с использованием исключений;
- 4-й, pipeline.

Я сам активно использую 2-й и 4-й, а исключений избегаю.

Варианты 1-й (г-но код) и 5-й (оверинжениринг) -- это примеры того, как делать не надо.

Если кому-то хочется таких же крутых штук, как Haskell, то проще всего взять и использовать Haskell. Или другие языки семейства ML: Scala, OCaml, F#, они не хуже.

Напоследок порекомендую книгу [Domain Modeling Made Functional. Scott Wlaschin](https://pragprog.com/book/swdddf/domain-modeling-made-functional). Прекрасное введение в функциональное программирование.
