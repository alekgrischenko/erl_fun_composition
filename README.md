В данном учебном проекте я рассматриваю способы композиции функций в Erlang.

На примере конкретной прикладной задачи я предлагаю 5 вариантов композиции. Начинаю с простых и понятных, и двигаюсь к более сложным способам, характерным для функционального программирования. Анализирую плюсы и минусы каждого варианта, рекомендую, что лучше использовать в реальном проекте.

Все варианты актуальны и для Elixir.


# Задача

У нас есть книжный магазин для котов. Он принимает заказы и доставляет книги.

У магазина есть API для создания заказа.

На входе API принимает json-данные, содержащие информацию о коте-заказчике, его адресс и книги, которые кот хочет заказать.

Например:
```
{
  "cat": "Tihon",
  "address": "Coolcat str 7/42 Minsk Belarus",
  "books": [
    {"title": "Domain Modeling Made Functional", "author": "Scott Wlaschin"},
    {"title": "Удовольствие от Х", "author": "Стивен Строгац"},
    {"title": "Distributed systems for fun and profit", "author": "Mikito Takada"}
  ]
}
```

На выходе из API мы имеем валидный бизнес-объект Order, который передается дальше в систему для обработки, или ошибку валидации.

Для проверки данных и создания валидного объекта Order нужно выполнить следующие шаги:
- проверить кота по имени
- проверить его адрес
- проверить каждую книгу в списке
- создать Order

Для этого у нас есть следущие функции:
```
-spec validate_incoming_data(JsonData :: map()) ->
    {ok, map()} | {error, invalid_incoming_data}.

-spec validate_cat(CatName :: binary()) ->
    {ok, cat()} | {error, cat_not_found}.

-spec validate_address(Address :: binary()) ->
    {ok, address()} | {error, invalid_address}.

-spec get_book(Title :: binary(), Author :: binary()) ->
    {ok, book()} | {error, {book_not_found, binary()}}.

-spec create_order(Cat :: cat(), Address :: address(), Books :: [book()]) ->
    order().
```

Нужно выполнить композицию этих функций.

[book_shop.erl](./blob/master/src/book_shop.erl)


# Вариант 1. Решение в лоб -- вложеные case.

Плюсы: очевидное
Минусы: трудно читать, трудно менять. А что, если шагов не 4, а 15?


# Вариант 2. Цепочка функций, без вложеных case, с накоплением данных в стейте.

Плюсы: понятное, читаемое, расширяемое
Минусы: копипаста, шаблонный код.


# Вариант 3. Решение на исключениях

Работает. Читаемо. Расширяемо. Имеет полное право на существование.
Но трудно отследить все точки выхода, найти все варианты, что может пойти не так.
ну и это не ФП путь


# Вариант 4. Pipeline. bind & sequence

Мы хотим игнорировать тот факт, что функции могут вернуть ошибку,
хотим работать только с happy path. ФП дает нам инструменты для этого. Попробуем эти инструменты.

Для соединения функций в цепочку удобна инфиксная форма вызова функции.

Префиксная форма: fun arg1 arg2
Инфиксная форма: arg1 fun arg2

В префикстой форме цепочка выглядит так:
bind(bind(bind(fun1, fun2), fun3), fun4)

В инфиксной форме так:
fun1 >>= fun2 >>= fun3 >>= fun4

Увы, в эрланге инфиксной формы для функций нет. Будем что-то придумывать.

## Какие вообще есть способы композиции?

точка, $, & или |> (pipe)
<$>, <*>
>>= bind, >> fmap
=<<
<=< >=> рыба


В эликсире
только |>

В эрланге ничего


## Еще одна проблема это то, что нам нужно не просто соединить функции в цепочку,

но еще сохранить промежуточные результаты, чтобы использовать их позже.

Вариант -- складывать все промежуточные результаты в некий State,
и пробрасывать этот State через все функции.

Сперва решение на Haskell, как образец, к которому хочется стремиться.
Затем решение на Erlang.


Плюсы: понятное, читаемое, расширяемое

Минусы:

Работает только с функциями, специально предназначеными для pipeline -- State на входе, {ok, State} на выходе.
другие функции приходится оборачивать, и тогда нет выйгрыша в сравнении с вариантом 2.

Типы проверяются диалайзером только поверхностно. {ok, term()} | {error, term()}.
а что там в term(), не проверяется.


# Вариант 5. do-нотация

Другой способ сохранять и использовать промежуточные результаты -- do-нотация.
В эрланге этого, конечно, нет. Но можно попытаться придумать некий DSL с похожей семантикой.

Тут тоже, сперва решение на Haskell, затем на Erlang.

Реализация не production ready, но для эксперимента ок.
Например, непонятно, как лучше обработать ситуацию, когда ключа-аргумента нет в стейте.
Сейчас там будет краш, со стектрейсом, показывающим кишки реализации.
То есть, пользователь этого DSL должен влезать в детали реализации.
Стало быть, я сделал недостаточно хорошую абстракцию.
Впрочем, это проблема многих DSL :)

Плюсы: типа, как в Хаскеле, по-крутому

Минусы:
нифига не как в Хаскеле, никакой проверки типов нет
ваши коллеги не скажут вам спасибо за такой код


# Выводы

Выводы
- можно написать без исключений? можно
- можно использовать исключения? можно
- можно ли сделать "как в хаскеле"? поиграться можно, а в прод не надо. Как это отлаживать? Как будут выглядеть стек-трейсы при крашах?

В реальности на практике я применяю варианты 2 и 4.
4й вариант подразумевает, что все функции соединяются одинаково.
В 2-м варианте много гибкости.

Вариант 3? Никто особо не удивится, если вы напишите такой код. Пишите, если хотите. Я так не делаю.

Вариант 5? Не делайте так. Хотите писать как в Хаскеле, пишите на Хаскеле :)

Во 2м варианте диалайзер прекрасно найдет все ошибки.
В 4-м кое-что может найти, но глубоко не полезет.
В 5-м варианте вообще ничего не проверяется.

порекомендовать книгу
Domain Modeling Made Functional. by Scott Wlaschin
